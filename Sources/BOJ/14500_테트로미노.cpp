#include <iostream>
using namespace std;
//주어진 칸의 왼쪽과 위에 있는 칸들은 이미 확인하여 다시 볼 필요가 없다고 가정할 때
//확인할 테트로미노 모양의 상대적 위치
const int tetromino[19][4][2]={
  {{0,0},{0,1},{0,2},{0,3}},
  {{0,0},{1,0},{2,0},{3,0}},
  {{0,0},{1,0},{0,1},{1,1}},
  {{0,0},{1,0},{0,1},{0,2}},
  {{0,0},{1,0},{1,1},{1,2}},
  {{0,0},{0,1},{0,2},{1,2}},
  {{0,0},{1,0},{1,-1},{1,-2}},
  {{0,0},{0,1},{1,0},{2,0}},
  {{0,0},{0,1},{1,1},{2,1}},
  {{0,0},{1,0},{2,0},{2,1}},
  {{0,0},{1,0},{2,0},{2,-1}},
  {{0,0},{1,0},{1,1},{2,1}},
  {{0,0},{0,1},{1,0},{1,-1}},
  {{0,0},{1,0},{1,-1},{2,-1}},
  {{0,0},{0,1},{1,1},{1,2}},
  {{0,0},{0,1},{0,2},{1,1}},
  {{0,0},{1,0},{1,-1},{2,0}},
  {{0,0},{1,0},{1,-1},{1,1}},
  {{0,0},{1,0},{1,1},{2,0}}
};
int N, M;
int num[500][500];
//{y,x}의 왼쪽과 위의 칸들을 모두 확인했을 때
//{y,x}에서 테트로미노를 놓아 얻는 수의 합의 최댓값 반환
int tetraSum(int y, int x){
  int ret=-1;
  for(int type=0; type<19; type++){
    int sum=0;
    for(int i=0; i<4; i++){
      int ny=y+tetromino[type][i][0], nx=x+tetromino[type][i][1];
      //type번 테트로미노가 범위밖을 나가는 경우 type번은 무시한다
      if(ny<0||nx<0||ny>=N||nx>=M){
        sum=-1;
        break;
      }
      sum += num[ny][nx];
    }
    ret = max(ret, sum);
  }
  return ret;
}
int main()
{
  cin >> N >> M;
  for(int i=0; i<N; i++)
    for(int j=0; j<M; j++)
      cin >> num[i][j];
  int ans=0;
  //왼쪽 위의 칸부터 오른쪽 아래로 확인한다
  for(int i=0; i<N; i++)
    for(int j=0; j<M; j++)
      ans = max(ans, tetraSum(i,j));
  cout << ans << endl;
}
